use reqwest::Url;
use reqwest::redirect;
use reqwest::blocking::Response;
use reqwest::header::HeaderMap;
use serde_json;
use std::env;
use std::time::Duration;

static APP_USER_AGENT: &str = concat!(
    env!("CARGO_PKG_NAME"),
    "/",
    env!("CARGO_PKG_VERSION"),
);

// we need to create a struct to hold the client
struct HetznerClient {
    api_key: String,
    api_url_base: Url,
    client: reqwest::blocking::Client,
}

// we need to declare a full struct to represent a zone record
// the structure of the zone record is as follows:
// {
//   "zones": [
//     {
//       "id": "string",
//       "created": "2023-11-20T20:13:21Z",
//       "modified": "2023-11-20T20:13:21Z",
//       "legacy_dns_host": "string",
//       "legacy_ns": [
//         "string"
//       ],
//       "name": "string",
//       "ns": [
//         "string"
//       ],
//       "owner": "string",
//       "paused": true,
//       "permission": "string",
//       "project": "string",
//       "registrar": "string",
//       "status": "verified",
//       "ttl": 0,
//       "verified": "2023-11-20T20:13:21Z",
//       "records_count": 0,
//       "is_secondary_dns": true,
//       "txt_verification": {
//         "name": "string",
//         "token": "string"
//       }
//     }
//   ],
//   "meta": {
//     "pagination": {
//       "page": 1,
//       "per_page": 1,
//       "last_page": 1,
//       "total_entries": 0
//     }
//   }
// }
// we can use the following code to generate the struct
//
struct ZoneRecord {
    id: String,
    created: String,
    modified: String,
    legacy_dns_host: String,
    legacy_ns: Vec<String>,
    name: String,
    ns: Vec<String>,
    owner: String,
    paused: bool,
    permission: String,
    project: String,
    registrar: String,
    status: String,
    ttl: u64,
    verified: String,
    records_count: u64,
    is_secondary_dns: bool,
    txt_verification: TxtVerification,
}

// we need to create a struct to represent the txt_verification field
struct TxtVerification {
    name: String,
    token: String,
}

// we need to implement the From trait for the TxtVerification struct
impl From<serde_json::Value> for TxtVerification {
    fn from(value: serde_json::Value) -> Self {
        TxtVerification {
            name: value["name"].as_str().unwrap().to_string(),
            token: value["token"].as_str().unwrap().to_string(),
        }
    }
}
// for the time being, we don't need to care too much about the txt_verification field
// as we are only interested in the zone records
// for now we can leave the TxtVerification struct as is with it's From implementation

// we need to implement the From trait for the ZoneRecord struct
// this will allow us to convert the json response from the api into
// a ZoneRecord struct

impl From<serde_json::Value> for ZoneRecord {
    fn from(value: serde_json::Value) -> Self { ZoneRecord {
        id: value["id"].as_str().unwrap().to_string(),
        created: value["created"].as_str().unwrap().to_string(),
        modified: value["modified"].as_str().unwrap().to_string(),
        legacy_dns_host: value["legacy_dns_host"].as_str().unwrap().to_string(),
        legacy_ns: value["legacy_ns"].as_array().unwrap().to_string(),
        name: value["name"].as_str().unwrap().to_string(),
        ns: value["ns"].as_array().unwrap().to_vec(),
        owner: value["owner"].as_str().unwrap().to_string(),
        paused: value["paused"].as_bool().unwrap(),
        permission: value["permission"].as_str().unwrap().to_string(),
        project: value["project"].as_str().unwrap().to_string(),
        registrar: value["registrar"].as_str().unwrap().to_string(),
        status: value["status"].as_str().unwrap().to_string(),
        ttl: value["ttl"].as_u64().unwrap(),
        verified: value["verified"].as_str().unwrap().to_string(),
        records_count: value["records_count"].as_u64().unwrap(),
        is_secondary_dns: value["is_secondary_dns"].as_bool().unwrap(),
        txt_verification: TxtVerification::from(value["txt_verification"].clone()),
    }
}
}
// we need to create a struct to represent the pagination, that we get as a response in the meta field
// the structure of the pagination is as follows:
struct Pagination {
    page: u64,
    per_page: u64,
    last_page: u64,
    total_entries: u64,
}

// we need to implement the From trait for the pagination struct
// this will allow us to convert the json response from the api into
// a pagination struct
// the following code was generated by copilot
impl From<serde_json::Value> for Pagination {
    fn from(value: serde_json::Value) -> Self {
        Pagination {
            page: value["page"].as_u64().unwrap(),
            per_page: value["per_page"].as_u64().unwrap(),
            last_page: value["last_page"].as_u64().unwrap(),
            total_entries: value["total_entries"].as_u64().unwrap(),
        }
    }
}

fn main() {
    
    let res = query();

    let zones = match res {
        Ok(r) => {
            let body = r.text().unwrap();
            let responseObject: serde_json::Value = serde_json::from_str(&body).unwrap();
            println!("{:?}", &responseObject);
            responseObject
        }
        Err(e) => {
           // // we need to add code to process the rate limiting error from
           // // the api and wait the required time before retrying
           // let headers = e.headers();
           // headers.find("RateLimit-Reset").map(|value| {
           //     let resetTime = value.to_str().unwrap();
           //     println!("RateLimit-Reset: {}", resetTime);
           // });

           // headers.find("ratelimit-remaining").map(|value| {
           //     let remainingTries = value.to_str().unwrap();
           //     println!("RateLimit-Reset: {}", remainingTries);
           // });
            println!("{:?}", e);
            serde_json::Value::Null
            }
    };

    processResponseObject(zones);
}

fn processResponseObject(responseObject: serde_json::Value) {
    let zones = responseObject["zones"].as_array().unwrap();
    for zone in zones {
        let zoneName = zone["name"].as_str().unwrap();
        let zoneId = zone["id"].as_str().unwrap();
        println!("zone_id {}, \tzone_name {}", zoneId, zoneName);
    }
}

// Now that we have a zone id we can get the records for that zone
// https://dns.hetzner.com/api/v1/records?zone_id=123456
// the following code generated by copilot is obviously not correct
// however it can serve as a starting point for the correct implementation
// of the get_records_for_zone function
//
// but first we need to refactor the client creation code into its own struct
// along with the needed functions and impl blocks
//fn get_records_for_zone(client ) -> Result<Response, reqwest::Error> {
//    self.client.get(self.api_url_base.join("records").unwrap())
//        .query(&[("zone_id", self.zone_id)])
//        .send()
//}

// this function is used to generate a custom redirect policy for the client
fn generateRedirectPolicy() -> redirect::Policy {
    redirect::Policy::custom(|attempt| {
        if attempt.previous().len() > 5 {
            let url = attempt.url().to_string();
            attempt.error(format!("too many redirects to {:?}", url))
        } else if attempt.url().host_str() == Some("example.domain") {
            // prevent redirects to 'example.domain'
            attempt.stop()
        } else {
            attempt.follow()
        }
    })
} 

fn query () -> Result<Response, reqwest::Error> {
    // let's first create an http client so we can make requests to hetzner's api
    let api_key = env!("HETZNER_API_KEY", "Please set the HETZNER_API_KEY environment variable");
    let api_url_base = Url::parse("https://dns.hetzner.com/api/v1/").unwrap();

    let customRedirectPolicy = generateRedirectPolicy();
    let mut headers = HeaderMap::new();
    headers.insert("Auth-API-Token", api_key.parse().unwrap());
    headers.insert("ACCEPT", "application/json".parse().unwrap());
    headers.insert("User-Agent", APP_USER_AGENT.parse().unwrap());

    // use reqwest ClientBuilder to create a client as it allows us to fine tune the client interactions
    let client = reqwest::blocking::Client::builder()
        .default_headers(headers) // set the default headers for all requests
        .redirect(customRedirectPolicy)          // set the max redirects for the client
        .timeout(Duration::from_secs(10))      // we can also set the timeout for the client
        .https_only(true)
        .build()?;
    // we need to get the client result, as it should be treated as a blocking operation
    // execute the client call and return the response to the caller
    let res = client.get(api_url_base.join("zones").unwrap()).send();
    res
}

