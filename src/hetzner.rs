use reqwest::header::HeaderMap;
use reqwest::redirect;
use reqwest::Url;
use serde::{self, Deserialize, Serialize};
use std::env;
use std::time::Duration;
use std::vec::Vec;

static APP_USER_AGENT: &str = concat!(
    env!("CARGO_PKG_NAME"),
    "/",
    env!("CARGO_PKG_VERSION"),
    // this will set the user agent to the following:
    // hetzner-robot-rs/0.1.0
);
//
// we need to create a struct to hold the client
pub struct HetznerClient {
    pub api_url_base: Url,
    pub client: reqwest::blocking::Client,
}

impl HetznerClient {
    #[allow(dead_code)]
    fn new(api_url_base: Url) -> Self {
        Self {
            api_url_base,
            client: reqwest::blocking::Client::new(),
        }
    }
}

impl Default for HetznerClient {
    fn default() -> Self {
        Self {
            api_url_base: Url::parse("https://dns.hetzner.com/api/v1/").unwrap(),
            client: _setup_client(),
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct VecZoneRecord {
    pub zones: Vec<ZoneRecord>,
}

impl VecZoneRecord {
    pub fn new() -> Self {
        VecZoneRecord { zones: Vec::new() }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ZoneRecord {
    pub id: String,
    created: String,
    modified: String,
    legacy_dns_host: String,
    legacy_ns: Vec<String>,
    pub name: String,
    ns: Vec<String>,
    owner: String,
    paused: bool,
    permission: String,
    project: String,
    registrar: String,
    status: String,
    ttl: u64,
    verified: String,
    records_count: u64,
    is_secondary_dns: bool,
    txt_verification: TxtVerification,
}

// we need to create a struct to represent the txt_verification field
#[derive(Debug, Serialize, Deserialize)]
pub struct TxtVerification {
    name: String,
    token: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Pagination {
    page: u64,
    per_page: u64,
    last_page: u64,
    total_entries: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RecordsResponse {
    meta: Pagination,
    pub zones: Vec<ZoneRecord>,
}

// Now that we have a zone id we can get the records for that zone
// https://dns.hetzner.com/api/v1/records?zone_id=123456
// the following code generated by copilot is obviously not correct
// however it can serve as a starting point for the correct implementation
// of the get_records_for_zone function
//
// but first we need to refactor the client creation code into its own struct
// along with the needed functions and impl blocks
//fn get_records_for_zone(client ) -> Result<Response, reqwest::Error> {
//    self.client.get(self.api_url_base.join("records").unwrap())
//        .query(&[("zone_id", self.zone_id)])
//        .send()
//}

// this function is used to generate a custom redirect policy for the client
fn generate_redirect_policy() -> redirect::Policy {
    redirect::Policy::custom(|attempt| {
        if attempt.previous().len() > 5 {
            let url = attempt.url().to_string();
            attempt.error(format!("too many redirects to {:?}", url))
        } else if attempt.url().host_str() == Some("example.domain") {
            // prevent redirects to 'example.domain'
            attempt.stop()
        } else {
            attempt.follow()
        }
    })
}

fn _setup_client() -> reqwest::blocking::Client {
    let custom_redirect_policy = generate_redirect_policy();
    let mut headers = HeaderMap::new();
    headers.insert("Auth-API-Token", _get_api_key().parse().unwrap());
    headers.insert("ACCEPT", "application/json".parse().unwrap());
    headers.insert("User-Agent", APP_USER_AGENT.parse().unwrap());
    let client = reqwest::blocking::Client::builder()
        .default_headers(headers) // set the default headers for all requests
        .redirect(custom_redirect_policy) // set the max redirects for the client
        .timeout(Duration::from_secs(10)) // we can also set the timeout for the client
        .https_only(true)
        .build();
    match client {
        Ok(c) => c,
        Err(e) => {
            println!("{:?}", e);
            panic!("Program failed to create http client")
        }
    }
}

fn _get_api_key() -> String {
    match std::env::var("HETZNER_API_KEY") {
        Ok(key) => key,
        Err(_) => {
            panic!("Please set the HETZNER_API_KEY environment variable");
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_api_key() {
        // Set up
        std::env::set_var("HETZNER_API_KEY", "test_api_key");
        // Execute
        let api_key = _get_api_key();

        // Verify
        assert_eq!(api_key, "test_api_key");

        // verify that an error is returned if the HETZNER_API_KEY
        // environment variable is not set
        std::env::remove_var("HETZNER_API_KEY");
        assert!(std::panic::catch_unwind(|| {
            let _ = _get_api_key();
        })
        .is_err());
    }
}
